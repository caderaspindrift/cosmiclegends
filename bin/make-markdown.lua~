#!/usr/bin/lua

local CONFIG = {
  appname      = "make-markdown.lua",
  bin_dir      = "./bin",
  build_dir    = "./build",
  errors       = true,
  extension    = ".md",
  extensions   = ".md;.yaml",
  ext_markdown = ".md",
  ext_yaml     = ".yaml",
  ext_recipe   = ".recipe",
  ignore       = "^(%.git|Makefile|%.test|%.)",
  index        = "intro",
  logformat    = "  %20s %-30s",
  out_suffix   = ".md",
  outdir       = "./out",
  outfile      = "build",
  recipe       = "clu",
  recipe_dir   = "./",
  src_dir      = "./src",
  summary      = true,
  verbose      = false,
  };

local lfs   = require "lfs"
local cli   = require "cliargs";
local lyaml = require "lyaml";

local function vprint() end;
local function eprint() end;

local function parse_yaml_to_tree(str)
  if not str then return false, nil end;

  local yaml_tree = lyaml.load(str);
  return yaml_structure ~= nil, yaml_structure;
end

local function parse_lines_to_yaml_tree(lines)
  if not lines then return false, nil end;
  local yaml_source = table.concat(tree, "\n");
  local successful_parse, yaml_tree = parse_yaml_to_tree(yaml_source);
  if   not successful_parse
  then eprint("YAML did not parse successfully.") 
       return false, nil;
  else vprint("YAML parse successful!");
       return true, yaml_tree
  end;
end;

function tprint(tbl, indent)
  if not indent then indent = 0 end
  local toprint = string.rep(" ", indent) .. "{\r\n"
  indent = indent + 2 
  for k, v in pairs(tbl) do
    toprint = toprint .. string.rep(" ", indent)
    if (type(k) == "number") then
      toprint = toprint .. "[" .. k .. "] = "
    elseif (type(k) == "string") then
      toprint = toprint  .. k ..  "= "   
    end
    if (type(v) == "number") then
      toprint = toprint .. v .. ",\r\n"
    elseif (type(v) == "string") then
      toprint = toprint .. "\"" .. v .. "\",\r\n"
    elseif (type(v) == "table") then
      toprint = toprint .. tprint(v, indent + 2) .. ",\r\n"
    else
      toprint = toprint .. "\"" .. tostring(v) .. "\",\r\n"
    end
  end
  toprint = toprint .. string.rep(" ", indent-2) .. "}"
  return toprint
end

local function split(str, pat)
   local t = {}  -- NOTE: use {n = 0} in Lua-5.0
   local fpat = "(.-)" .. pat
   local last_end = 1
   local s, e, cap = str:find(fpat, 1)
   while s do
      if s ~= 1 or cap ~= "" then
     table.insert(t,cap)
      end
      last_end = e+1
      s, e, cap = str:find(fpat, last_end)
   end
   if last_end <= #str then
      cap = str:sub(last_end)
      table.insert(t, cap)
   end
   return t
end

-- =============================================================================================================
-- code by GianlucaVespignani - 2012-03-04; 2013-01-26
-- Search files in a path, alternative in sub directory
-- @param dir_path string (";" for multiple paths supported)
-- @param filter string - eg.: ".txt" or ".mp3;.wav;.flac"
-- @param s bool - search in subdirectories
-- @param pformat format of data - 'system' for system-dependent number; nil or string with formatting directives
-- @return  files, dirs - files and dir are tables {name, modification, path, size}

function file_search(dir_path, filter, s, pformat)
    -- === Preliminary functions ===
    -- comparison function like the IN() function like SQLlite, item in a array
    -- useful for compair table for escaping already processed item
    -- Gianluca Vespignani 2012-03-03
    local c_in = function(value, tab)
        for k,v in pairs(tab) do
            if v==value then
                return true
            end
        end
        return false
    end

    local string = string    -- http://lua-users.org/wiki/SplitJoin
    function string:split(sep)
        local sep, fields = sep or ":", {}
        local pattern = string.format("([^%s]+)", sep)
        self:gsub(pattern, function(c) fields[#fields+1] = c end)
        return fields
    end

    local ExtensionOfFile = function(filename)
    local rev = string.reverse(filename)
    local len = rev:find("%.")
    local rev_ext = rev:sub(1,len)

    return string.reverse(rev_ext)
    end

    -- === Init ===
    dir_path   = dir_path or cwd
    filter     = string.lower(filter) or "*"
    extensions = filter:split(";")
    s = s or false -- as /s : subdirectories

    if pformat == 'system' then    -- if 4th arg is explicity 'system', then return the system-dependent number representing date/time
        os_date = function(os_time)
            return os_time
        end
    else
        -- if 4th arg is nil use default, else it could be a string that respects the Time formatting directives
        pformat = pformat or "%Y/%m/%d" -- eg.: "%Y/%m/%d %H:%M:%S"
        os_date = function(os_time)
            return os.date(pformat, os_time)
        end
    end

    -- == MAIN ==
    local files = {}
    local dirs  = {}
    local paths = dir_path:split(";")
    for i,path in ipairs(paths) do
        for f in lfs.dir(path) do
            if f ~= "." and f ~= ".." then
                local attr = lfs.attributes ( path.."/"..f )
                if attr.mode == "file" then
                    if filter=="*"
                    or c_in( string.lower( ExtensionOfFile(f) ), extensions)
                    then
                        table.insert(files,{
                            name = f,
                            modification = os_date(attr.modification) ,
                            path = path.."/",
                            size = attr.size
                        })
                    end
                else
                    if filter=="*" then            -- if attr.mode == "directory" and file ~= "." and file ~= ".." then end
                        table.insert(dirs,{
                            name = f ,
                            modification = os_date(attr.modification) ,
                            path = path.."/",
                            size = attr.size
                        })
                    end
                    if s and attr.mode == "directory" then
                        local subf={}
                        local subd={}
                        subf, subd = file_search(path.."/"..f, filter, s, pformat)
                        for i,v in ipairs(subf) do
                            table.insert(files,{
                                name = v.name ,
                                modification = v.modification ,
                                path = v.path,
                                size = v.size
                            })
                        end
                        for i,v in ipairs(subd) do
                            table.insert(dirs,{
                                name = v.name ,
                                modification = v.modification ,
                                path = v.path,
                                size = v.size
                            })
                        end
                    end
                end
            end
        end
    end
    return files,dirs

--[=[    ABOUT ATTRIBUTES
> for k,v in pairs(a) do print(k..' \t'..v..'') end
dev     2
change  1175551262    -- date of file Creation
access  1235831652
rdev    2
nlink   1
uid     0
gid     0
ino     0
mode    file
modification    1181692021 -- Date of Last Modification
size    805 in byte
    ]=]
end

local function vprint(s, l) if CONFIG.verbose then print(string.format(CONFIG.logformat, s or "", l or "")) end; end;
local function eprint(s, l) if CONFIG.errors  then print(string.format(CONFIG.logformat, s or "", l or "")) end; end;
local function sprint(s, l) if CONFIG.summary then print(string.format(CONFIG.logformat, s or "", l or "")) end; end;

-- http://lua-users.org/wiki/FileInputOutput

local function get_slug_from_name(filename)
  filename = string.gsub(filename, "^%" .. CONFIG.src_dir,             "");
  filename = string.gsub(filename, "%"  .. CONFIG.ext_markdown .. "$", "");
  filename = string.gsub(filename, "%"  .. CONFIG.ext_yaml ..     "$", "");
  filename = string.gsub(filename, "^/",                               "");
  filename = string.gsub(filename, "/$",                               "");
  return filename;
end;

local function path_level(path)
  if type(path) ~= "string" then return 0 end;
  vprint("path is", path);
  path = get_slug_from_name(path);
  local pathdirs = split(path, "/");
  local level = #pathdirs;
  if string.find(path, CONFIG.index) 
     then vprint("*** found an index", path) 
     else level = level + 1;
     end;
  return level;
end;

-- see if the file exists
local function file_exists(file)
  local f = io.open(file, "rb")
  if f then f:close() end
  return f ~= nil
end -- function file_exists

local format_yaml = {}

format_yaml.glossary = 
function(yaml_structure, return_format) -- glossary file
  if not return_format == "table" or not return_format == "text"
  then eprint("Unknown return format to format_yaml.glossary:", return_format);
  end;

  if type(yaml_structure) ~= "table"
  then eprint("YAML structure is not table. (Parse it first?)");
  end;

  local markdown_section_started = false;
  for item, value in pairs(yaml_structure)
  do  vprint("Found a glossary file:")
      local term, def = "", "";
      local indent    = "    ";
      local lines     = {};
      if   item == "metadata"
      then -- skip it
      else -- not metadata, don't skip
           if   not markdown_section_started
           then table.insert(slurped, string.rep(":", 20) .. " glossary " .. string.rep(":", 40));
                markdown_section_started = true;
           end; -- not markdown section started

           if   value.def and type(value.def) == "string" 
           then slurped = slurped .. "\n"             .. item;
                slurped = slurped .. "\n\n" .. indent .. value.def;

                if   value.hd_equiv
                then slurped = slurped .. "(*" .. value.hd_equiv .. "* in Harmony Drive.)";
                end; -- if value hd_equiv

                slurped = slurped .. "\n\n";
           else eprint("Undefined term: " .. item .. " has no definition!");
           end;  -- if value.def = string
  
        end; -- else item not metadata
    end;   -- for item, value in pairs

    if     return_format == "string"
    then   return table.concat(slurped, "\n");
    elseif not return_format or return_format == "table"
    then   return slurped; 
    elseif return_format == "yaml"
    then   return lyaml.load( table.concat(slurped, "\n")), true;
    end;
end;

format_yaml.character = function(yaml, return_format) -- character statblock
  if type(yaml_structure) ~= "table"
  then eprint("YAML structure is not table. (Parse it first?)");
  end;

  if not return_format == "table" or not return_format == "text"
  then eprint("Unknown return format to format_yaml.character:", return_format);
  end;

  vprint("Found a character in YAML!");

  local slurped   = "";
  local yaml_data = file.yaml_structure;
  local bio       = yaml_data.bio;
  local history   = yaml_data.history;
  local powers    = yaml_data.powers;
  local stats     = yaml_data.stats;
  local weapons   = yaml_data.weapons;

  local function slurp_bio_field(yfield, caption)
  vprint("generating bio line " .. caption);
  if bio[yfield] then slurped = slurped .. "\n- **" .. caption .. ":** " .. bio[yfield]; end;
  end;

  local function slurp_stats_field(yfield, caption)
  local field_path = split(yfield, ":");
  local value = stats[yfield];
  if     type(value) ~= "table" and #field_path == 1 then slurped = slurped.."\n- **"..caption..":** "..stats[yfield];
  elseif #field_path == 1 and value[1] == "*"        then value   = table.concat(value, ", ");
  elseif #field_path > 1                             then for i, field in pairs(value) do value = value[field]; end;
  end;
  if   value
  then vprint("generating stat line " .. caption);
  slurped = slurped .. string.rep("  ", 2 * (#field_path)) .. "\n- **" .. caption .. ":**" .. value;
  end;
  end;

  slurped = slurped .. "\n# " .. (metadata.title or "Character");

  if   metadata.anchor or metadata.classes
  then slurped = slurped .. " {";
  if metadata.anchor   then slurped = slurped .. "#" .. metadata.anchor  end;
  if metadata.classes then slurped = slurped .. " ." .. metadata.classes end;
  slurped = slurped .. "}\n";
  end;

  if   bio
  then vprint("generating bio block");
  slurped = slurped .. "::::::::::: { .bio } ::::::::::::::::"
  slurp_bio_field("real_name",    "Real Name"   );
  slurp_bio_field("occupation",   "Occupation"  );
  slurp_bio_field("legal_status", "Legal Status");

  if   bio.gender and bio.gender.desc and bio.gender.pronouns
  then slurped = slurped .. "\n- **Gender:**" .. bio.gender.desc .. " (" ..  bio.gender.pronouns .. ")";
  else slurp_bio_field("gender",     "Gender");
  slurp_bio_field("pronouns", "Pronouns");
  end;

  slurp_bio_field("identity",             "Identity");
  slurp_bio_field("former_aliases", "Former Aliases");
  slurp_bio_field("place_of_birth", "Place of Birth");
  slurp_bio_field("marital_status", "Marital Status");

  if   bio.height or bio.weight or bio.eyes or bio.hair
  then vprint("generating bio2 block");
  slurped = slurped .. ":::::::::::::::::::::::::::::::::::::";
  slurped = slurped .. "::::::::::: { .bio2 } :::::::::::::::";
  slurp_bio_field("height", "Height");
  slurp_bio_field("weight", "Weight");
  slurp_bio_field("eyes",   "Eyes"  );
  slurp_bio_field("hair",   "Hair"  );
  end; 
  slurped = slurped .. ":::::::::::::::::::::::::::::::::::::";
  end; -- if bio
  if history then slurped = slurped .. "\n\n**History:**\n" .. history; end;
  if powers  then slurped = slurped .. "\n\n**Powers:**\n"  .. powers;  end;
  if weapons then slurped = slurped .. "\n\n**Weapons:**\n" .. weapons; end;
  if stats
  then vprint("generating stats block");
  slurped = slurped .. "::::::::::: { .stats } ::::::::::::::";
  if metadata.title then slurped = slurped .. "\n\n## " .. metadata.title .. "\n\n"; end;
  slurp_stats_field("class",                "Class"      );
  slurp_stats_field("approaches",           "Approaches" );
  slurp_stats_field("approaches:action",    "Action"     );
  slurp_stats_field("approaches:adventure", "Adventure"  );
  slurp_stats_field("approaches:detective", "Detective"  );
  slurp_stats_field("approaches:mystery",   "Mystery"    );
  slurp_stats_field("approaches:suspense",  "Suspense"   );
  slurp_stats_field("health",               "Health"     );
  slurp_stats_field("might",                "Might"      );
  slurp_stats_field("power_words",          "Power Words");
  slurp_stats_field("power_words:core",     "Core"       );
  slurp_stats_field("power_words:personal", "Personal"   );
  slurp_stats_field("power_words:nova",     "Nova"       );
  slurp_stats_field("abilities:*",          "Abilities"  );
  slurp_stats_field("skills:*",             "Skills"     );
  slurp_stats_field("ideals:*",             "Ideals"     );
  slurped = slurped .. ":::::::::::::::::::::::::::::::::::::";
  end;
  
end;

format_yaml.list = 
function(yaml, return_format) -- a list of people, places, or things
  if type(yaml_structure) ~= "table"
  then eprint("YAML structure is not table. (Parse it first?)");
  end;

   local markdown_section_started = false;
end;

format_yaml.place = 
function(yaml, return_format) -- a place
  if type(yaml_structure) ~= "table"
  then eprint("YAML structure is not table. (Parse it first?)");
  end;

  local markdown_section_started = false;
end;

format_yaml.unknown = 
function(yaml, unknown_xformat, file, return_format) -- unknown xformat
  if type(yaml_structure) ~= "table"
  then eprint("YAML structure is not table. (Parse it first?)");
  end;

  eprint("Unknown format for yaml block in " .. file .. ": " .. unknown_xformat);
end;

local function get_file_type_from_name(filename)
  if     string.find(filename, "%" .. CONFIG.ext_yaml     .. "$") then return "yaml"
  elseif string.find(filename, "%" .. CONFIG.ext_markdown .. "$") then return "markdown"
  elseif string.find(filename, "%" .. CONFIG.ext_recipe   .. "$") then return "recipe"
                                                                  else return "unknown"
  end;
end;

-- get all lines from a file, returns an empty list/table if the file does not exist
local function slurp(filename, no_parse)

  string.gsub(filename,"\n+$",""); -- remove extra newlines at the end

  local file    = {};
  file.base     = filename;
  file.stub     = get_slug_from_name(filename);
  file.type     = get_file_type_from_name(filename);
  file.markdown = file.stub .. CONFIG.ext_markdown;
  file.yaml     = file.stub .. CONFIG.ext_yaml;
  file.recipe   = file.stub .. CONFIG.ext_recipe;

  vprint("looking for: " .. file.base);

  if     file_exists(file.base)     then vprint("> File found: "   ..file.base    ); file.is_base     = true;
  elseif file_exists(file.yaml)     then vprint("> File found: "   ..file.yaml    ); file.is_yaml     = true;
  elseif file_exists(file.markdown) then vprint("> File found: "   ..file.markdown); file.is_markdown = true;
  else   eprint("> Couldn't find: "..file.base.." or "..file.yaml.." or "..file.markdown);
  end;

  lines = {};
  for line in io.lines(file.base) do lines[#lines + 1] = line end; -- for line in io.lines(file.base)
       
  local slurped = "\n" .. table.concat(lines, "\n") .. "\n";
       
  if   not no_parse
  then -- normalize the number of octothorpes
       local octo, _    = string.match(slurped, "(#+)");
       local octo_level = string.len(octo or "");
       if   octo_level > 1 
       then local mod = octo_level - 1;
            local oldhash = "\n" .. string.rep("#", mod);
            local newhash = "\n";
            slurped = string.gsub(slurped, oldhash, newhash);
       end; -- if octo_level > 1
  
       local level = get_path_level(file);
       vprint(get_slug_from_name(file), "### should be " .. level .. ", is " .. octo_level);
  
       if   level >= 1
       then local mod = level - 1;
            local oldhash = "\n#";
            local newhash = "\n#" .. string.rep("#", mod)
            slurped = string.gsub(slurped, oldhash, newhash);
            slurped = string.gsub(slurped, "\n#####+", "\n#####");
            -- handle the H6 headings
            slurped = string.gsub(slurped, "\n:#", "\n######");
       end; -- if level
       
       if   file.is_markdown
       then slurped = slurped .. "\n<!-- source file of preceeding: " .. file.markdown .. " -->\n"
       end;
  end; -- if not no_parse


  local lines = split(slurped, "\n");
  return lines, slurped;
        
end; -- function slurp
   
local function get_file_contents(filename, no_parse)
  local file_type = get_file_type_from_name(filename);
  no_parse = no_parse or file_type == "recipe" or file_type == "yaml";

  local lines, lines_text = slurp(filename, no_parse);
  return (file_type == "yaml" and parse_lines_to_yaml_tree(lines)) or lines_text;
end;

local function write_to_file(file, contents)
  local f = io.open(file, "wb");
  f:write(contents);
  f:close();
end; -- function write_to_file

local outtxt, FILES, DIRS, BUILD, USED, ERR = "", {}, {}, {}, {}, {};

local function load_fs()
  files, dirs = file_search(CONFIG.src_dir, "*", true)
  for k, v in pairs(dirs)
  do  if   string.find(v.path, CONFIG.ignore) 
      then vprint("Skipping directory", v.name); 
           break 
      end; -- if ignore

      local filename = get_slug_from_name(v.path .. v.name);
      DIRS[filename] = true;
      vprint("Learning directory location", filename);
  end; -- for k, v
  
  for k, v in pairs(files)
  do if     string.find(v.path, CONFIG.ignore) 
     then   break 
     elseif string.find(v.name, "%" .. CONFIG.ext_markdown .. "$") 
         or string.find(v.name, "%" .. CONFIG.ext_yaml     .. "$")
     then   local filename  = get_slug_from_name(v.path..v.name);
            local pathdirs  = split(filename, "/");
            FILES[filename] = true;
     end; -- if markdown or yaml
  end; -- for k, v
  return files, dirs;
end; -- function load_fs

local TEMPLATE = {};

local function add_line(line)
  if   USED[line]
  then vprint("trying to add line [", line, "] but it's already used");
  end; -- if USED[line]

  USED[line] = true;

  if     FILES[line]
  then   vprint("found a FILES entry for: ", line);

         local file_yaml = CONFIG.src_dir .. "/" .. line .. CONFIG.ext_yaml;
         local file_md   = CONFIG.src_dir .. "/" .. line .. CONFIG.ext_markdown;

         if     file_exists(file_md)   then table.insert(BUILD, file_md);
         elseif file_exists(file_yaml) then table.insert(BUILD, file_yaml);
         end; -- if file_md

         USED[line] = true;
  elseif FILES[line] and USED[line]
  then   vprint("skipping entry", line);
  else   eprint("this doesn't exist", line);
  end; -- if FILES[line]
end; -- add_line

local function parse_recipe_line(line)
  if string.len(line) > 80 then eprint("Error: line is too long."); end;

  local asterisk, template = false, false;
  line = string.gsub(line, "/$", ""); -- strip extraneous ending slash: file/ -> file

  if   string.find(line, "/%*$")
  then asterisk = true;
       line = string.gsub(line, "/%*$", "");
       vprint("Found an asterisk: ", line);
  end; -- if string.find(line)

  if   string.find(line, "/?::[a-z]+$")
  then vprint("looks like a template", line);
       template = string.match(line, "/?::([a-z]+)$");
       vprint("i think it's this template", template);
       line = string.gsub(line, "/?::[a-z]+$", "");

       if   not TEMPLATE[template] 
       then template = nil; 
            vprint("the template doesn't exist")
       else vprint("the template DOES exist!")
       end; -- if not TEMPLATE[template]

  end; -- if matches template syntax

  if string.find(line, "^>")
  then -- found an output redirect line
         local outfile = string.gsub(line, "^>%s*", "");
               outfile = string.gsub(outfile, ".out$", "");
         CONFIG.outfile = outfile;
         vprint("setting the output file", "\"" .. outfile .. "\"");
  elseif string.find(line, "^#")
  then   -- found a comment
         vprint("comment:", line);
  elseif DIRS[line] 
  then   --
         vprint("found a directory", line);
         vprint("looking for index", line .. "/" .. CONFIG.index);
         parse_recipe_line(line .. "/" .. CONFIG.index);
  
         if template
         then vprint("found a template call", line .. "/::" .. template);
              for k, v in pairs(TEMPLATE[template]) 
              do  vprint("beep:", k .. ":" .. v);
                  parse_recipe_line(v(line));
              end; -- for k, v
         end; -- if template
   
         if asterisk 
         then vprint("found a /* construction", line .. "/*");
              local dir = CONFIG.src_dir .. "/" .. line;
              vprint("looking for files in ", dir)
              local md_files, _ = file_search(dir, CONFIG.extensions);
  
              vprint("found this many", #md_files .. " files");
              for k, v in pairs(md_files)
              do  local sl = v.name;
                  sl = string.gsub(sl, "%" .. CONFIG.ext_markdown .. "$", "");
                  sl = string.gsub(sl, "%" .. CONFIG.ext_yaml     .. "$", "");
                  parse_recipe_line(line .. "/" .. sl)
              end; -- for k, v
         end; -- if asterisk
  
  else add_line(line);
  end; -- if to determine how to handle line
end; -- function


local function recipe_list()
  local files, dirs = file_search(CONFIG.recipe_dir, CONFIG.ext_recipe, false)
  sprint("Listing Recipes:", #files .. " known");
  sprint("Recipe directory", CONFIG.recipe_dir);
  for k, v in pairs(files) 
  do local recipe_to_show = 
             string.format(
               CONFIG.logformat,  -- format
               v.path .. v.name,  
               CONFIG.bin_dir .. 
                 "/" .. 
               CONFIG.appname .. 
                 " " .. 
               string.gsub(v.name, CONFIG.ext_recipe, "")
             );
     sprint(recipe_to_show);
  end; -- for k, v
          
  os.exit(); -- exits
end; -- function recipe_list

-- ===================================
-- Command line interface
-- https://lua-cliargs.netlify.com/#/
-- ===================================

cli:set_name(CONFIG.appname);
cli:set_description("it creates the .md files we need");

cli:splat("RECIPE", "the recipe to build", "", 1);
-- cli:argument("RECIPE", "the recipe to build");

cli:option("-o, --outfile=OUTFILE", "specify the outfile");

cli:flag(  "-v, --verbose",         "be more wordy than usual",  false);
cli:flag(  "-q, --quiet",           "don't summarize each step", false);
cli:flag(  "-l, --list",            "list the known recipes",    false);
cli:flag(  "-y, --yaml",            "parse YAML files",           true); -- true = default to ON
cli:flag(  "-e, --[no-]errors",     "show errors",                true); -- true = default to OFF 

local args, err = cli:parse(arg);
if not args then cli:print_help(); os.exit(1); end;
if err then print(string.format("%s: %s", cli.name, err)); os.exit(1); end;

if args and args.list then recipe_list(); os.exit(); end;

if args.quiet   then CONFIG.summary = false else CONFIG.summary = true;  end;
if args.verbose then CONFIG.verbose = true  else CONFIG.verbose = false; end;
if args.errors  then CONFIG.errors  = true  else CONFIG.errors  = false; end;
if args.yaml    then CONFIG.yaml    = true  else CONFIG.yaml    = false; end;

if   args.RECIPE  
then CONFIG.recipe  = args.RECIPE;
     vprint("args.RECIPE is " .. args.RECIPE);
     CONFIG.outfile = args.RECIPE;
end; -- if args.RECIPE

if args.outfile then CONFIG.outfile = args.outfile end;

-- =======================================
-- Everything above this is initialization
-- =======================================
-- =======================================
-- =======================================
-- =======================================

-- start run -----------------------------
vprint("Running in verbose mode");
sprint("Showing summaries");

-- read the recipe -----------------------
sprint("reading recipe", CONFIG.recipe or "NIL");
local recipe_lines, recipe_text = slurp(CONFIG.recipe_dir .. "/" .. CONFIG.recipe .. CONFIG.ext_recipe, true);
if not recipe_lines then eprint("Can't read that recipe file: " .. (CONFIG.recipe or "NIL")); os.exit() end;

sprint("recipe read", #recipe_lines .. " lines");

-- parse the filesystem tree ---------------------------------------
sprint("Loading the filesystem map", "source = " .. CONFIG.src_dir );
load_fs();

-- parse the recipe ------------------------------------
if   type(recipe_lines) ~= "table" 
then eprint("Error: recipe_lines isn't a table"); os.exit(1);
else for _, i in pairs(recipe_lines) do parse_recipe_line(i) end;
end

-- list all the files ---------------------------------
-- (for debugging)
-- for i, v in pairs(FILES) do vprint("FILE:", i);  end; -- all the files we've found
-- for i, v in pairs(BUILD) do vprint("BUILD:", v); end; -- all that we've added to the build

-- slurp other files ----------------------------------
sprint("reading other files now", #BUILD .. " files");
for i, filename in pairs(BUILD) 
do  vprint("Getting contents of ", filename);
    local lines, filetext = get_file_contents(filename);
    outtxt = outtxt .. (filetext or "");
end; -- for i, v

-- save the output ------------------------------------------------------------
local outfile = CONFIG.build_dir .. "/" .. CONFIG.outfile .. CONFIG.out_suffix;

sprint("Writing to file", outfile);
sprint("Content size is", string.len(outtxt) .. " characters");
write_to_file(outfile, outtxt);

-- notify of errors -----------------------------------------------------------
sprint("number of errors", (#ERR or 0) .. " error" .. ((#ERR and #ERR == 1) and "" or "s" ));
if   #ERR 
then for i, v in pairs(ERR) 
     do local errmsg = "Alert: Missing file";
        if   string.find(v, CONFIG.index .. "$") 
        then errmsg = "Warning: Missing index"; 
        end;
        eprint(errmsg, v)
        end; -- for i, v in pairs(ERR)
end; -- if #ERR

